// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: opentelemetry/proto/metrics/v1/metrics.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// AggregationTemporality defines how a metric aggregator reports aggregated
/// values. It describes how those values relate to the time interval over
/// which they are aggregated.
enum Opentelemetry_Proto_Metrics_V1_AggregationTemporality: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// UNSPECIFIED is the default AggregationTemporality, it MUST not be used.
    case unspecified // = 0

    /// DELTA is an AggregationTemporality for a metric aggregator which reports
    /// changes since last report time. Successive metrics contain aggregation of
    /// values from continuous and non-overlapping intervals.
    ///
    /// The values for a DELTA metric are based only on the time interval
    /// associated with one measurement cycle. There is no dependency on
    /// previous measurements like is the case for CUMULATIVE metrics.
    ///
    /// For example, consider a system measuring the number of requests that
    /// it receives and reports the sum of these requests every second as a
    /// DELTA metric:
    ///
    ///   1. The system starts receiving at time=t_0.
    ///   2. A request is received, the system measures 1 request.
    ///   3. A request is received, the system measures 1 request.
    ///   4. A request is received, the system measures 1 request.
    ///   5. The 1 second collection cycle ends. A metric is exported for the
    ///      number of requests received over the interval of time t_0 to
    ///      t_0+1 with a value of 3.
    ///   6. A request is received, the system measures 1 request.
    ///   7. A request is received, the system measures 1 request.
    ///   8. The 1 second collection cycle ends. A metric is exported for the
    ///      number of requests received over the interval of time t_0+1 to
    ///      t_0+2 with a value of 2.
    case delta // = 1

    /// CUMULATIVE is an AggregationTemporality for a metric aggregator which
    /// reports changes since a fixed start time. This means that current values
    /// of a CUMULATIVE metric depend on all previous measurements since the
    /// start time. Because of this, the sender is required to retain this state
    /// in some form. If this state is lost or invalidated, the CUMULATIVE metric
    /// values MUST be reset and a new fixed start time following the last
    /// reported measurement time sent MUST be used.
    ///
    /// For example, consider a system measuring the number of requests that
    /// it receives and reports the sum of these requests every second as a
    /// CUMULATIVE metric:
    ///
    ///   1. The system starts receiving at time=t_0.
    ///   2. A request is received, the system measures 1 request.
    ///   3. A request is received, the system measures 1 request.
    ///   4. A request is received, the system measures 1 request.
    ///   5. The 1 second collection cycle ends. A metric is exported for the
    ///      number of requests received over the interval of time t_0 to
    ///      t_0+1 with a value of 3.
    ///   6. A request is received, the system measures 1 request.
    ///   7. A request is received, the system measures 1 request.
    ///   8. The 1 second collection cycle ends. A metric is exported for the
    ///      number of requests received over the interval of time t_0 to
    ///      t_0+2 with a value of 5.
    ///   9. The system experiences a fault and loses state.
    ///   10. The system recovers and resumes receiving at time=t_1.
    ///   11. A request is received, the system measures 1 request.
    ///   12. The 1 second collection cycle ends. A metric is exported for the
    ///      number of requests received over the interval of time t_1 to
    ///      t_0+1 with a value of 1.
    ///
    /// Note: Even though, when reporting changes since last report time, using
    /// CUMULATIVE is valid, it is not recommended. This may cause problems for
    /// systems that do not use start_time to determine when the aggregation
    /// value was reset (e.g. Prometheus).
    case cumulative // = 2
    case UNRECOGNIZED(Int)

    init() {
        self = .unspecified
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .delta
        case 2: self = .cumulative
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .delta: return 1
        case .cumulative: return 2
        case .UNRECOGNIZED(let i): return i
        }
    }
}

#if swift(>=4.2)

extension Opentelemetry_Proto_Metrics_V1_AggregationTemporality: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Opentelemetry_Proto_Metrics_V1_AggregationTemporality] = [
        .unspecified,
        .delta,
        .cumulative,
    ]
}

#endif // swift(>=4.2)

/// A collection of InstrumentationLibraryMetrics from a Resource.
struct Opentelemetry_Proto_Metrics_V1_ResourceMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The resource for the metrics in this message.
    /// If this field is not set then no resource info is known.
    var resource: Opentelemetry_Proto_Resource_V1_Resource {
        get { return self._resource ?? Opentelemetry_Proto_Resource_V1_Resource() }
        set { self._resource = newValue }
    }

    /// Returns true if `resource` has been explicitly set.
    var hasResource: Bool { return self._resource != nil }
    /// Clears the value of `resource`. Subsequent reads from it will return its default value.
    mutating func clearResource() { self._resource = nil }

    /// A list of metrics that originate from a resource.
    var instrumentationLibraryMetrics: [Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _resource: Opentelemetry_Proto_Resource_V1_Resource?
}

/// A collection of Metrics produced by an InstrumentationLibrary.
struct Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The instrumentation library information for the metrics in this message.
    /// Semantically when InstrumentationLibrary isn't set, it is equivalent with
    /// an empty instrumentation library name (unknown).
    var instrumentationLibrary: Opentelemetry_Proto_Common_V1_InstrumentationLibrary {
        get { return self._instrumentationLibrary ?? Opentelemetry_Proto_Common_V1_InstrumentationLibrary() }
        set { self._instrumentationLibrary = newValue }
    }

    /// Returns true if `instrumentationLibrary` has been explicitly set.
    var hasInstrumentationLibrary: Bool { return self._instrumentationLibrary != nil }
    /// Clears the value of `instrumentationLibrary`. Subsequent reads from it will return its default value.
    mutating func clearInstrumentationLibrary() { self._instrumentationLibrary = nil }

    /// A list of metrics that originate from an instrumentation library.
    var metrics: [Opentelemetry_Proto_Metrics_V1_Metric] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _instrumentationLibrary: Opentelemetry_Proto_Common_V1_InstrumentationLibrary?
}

/// Defines a Metric which has one or more timeseries.
///
/// The data model and relation between entities is shown in the
/// diagram below. Here, "DataPoint" is the term used to refer to any
/// one of the specific data point value types, and "points" is the term used
/// to refer to any one of the lists of points contained in the Metric.
///
/// - Metric is composed of a metadata and data.
/// - Metadata part contains a name, description, unit.
/// - Data is one of the possible types (Gauge, Sum, Histogram, etc.).
/// - DataPoint contains timestamps, labels, and one of the possible value type
///   fields.
///
///     Metric
///  +------------+
///  |name        |
///  |description |
///  |unit        |     +------------------------------------+
///  |data        |---> |Gauge, Sum, Histogram, Summary, ... |
///  +------------+     +------------------------------------+
///
///    Data [One of Gauge, Sum, Histogram, Summary, ...]
///  +-----------+
///  |...        |  // Metadata about the Data.
///  |points     |--+
///  +-----------+  |
///                 |      +---------------------------+
///                 |      |DataPoint 1                |
///                 v      |+------+------+   +------+ |
///              +-----+   ||label |label |...|label | |
///              |  1  |-->||value1|value2|...|valueN| |
///              +-----+   |+------+------+   +------+ |
///              |  .  |   |+-----+                    |
///              |  .  |   ||value|                    |
///              |  .  |   |+-----+                    |
///              |  .  |   +---------------------------+
///              |  .  |                   .
///              |  .  |                   .
///              |  .  |                   .
///              |  .  |   +---------------------------+
///              |  .  |   |DataPoint M                |
///              +-----+   |+------+------+   +------+ |
///              |  M  |-->||label |label |...|label | |
///              +-----+   ||value1|value2|...|valueN| |
///                        |+------+------+   +------+ |
///                        |+-----+                    |
///                        ||value|                    |
///                        |+-----+                    |
///                        +---------------------------+
///
/// All DataPoint types have three common fields:
/// - Labels zero or more key-value pairs associated with the data point.
/// - StartTimeUnixNano MUST be set to the start of the interval when the data's
///   type includes an AggregationTemporality. This field is not set otherwise.
/// - TimeUnixNano MUST be set to:
///   - the moment when an aggregation is reported (independent of the
///     aggregation temporality).
///   - the instantaneous time of the event.
struct Opentelemetry_Proto_Metrics_V1_Metric {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// name of the metric, including its DNS name prefix. It must be unique.
    var name: String = String()

    /// description of the metric, which can be used in documentation.
    var description_p: String = String()

    /// unit in which the metric value is reported. Follows the format
    /// described by http://unitsofmeasure.org/ucum.html.
    var unit: String = String()

    /// Data determines the aggregation type (if any) of the metric, what is the
    /// reported value type for the data points, as well as the relatationship to
    /// the time interval over which they are reported.
    ///
    // TODO: Update table after the decision on:
    /// https://github.com/open-telemetry/opentelemetry-specification/issues/731.
    /// By default, metrics recording using the OpenTelemetry API are exported as
    /// (the table does not include MeasurementValueType to avoid extra rows):
    ///
    ///   Instrument         Type
    ///   ----------------------------------------------
    ///   Counter            Sum(aggregation_temporality=delta;is_monotonic=true)
    ///   UpDownCounter      Sum(aggregation_temporality=delta;is_monotonic=false)
    ///   ValueRecorder      TBD
    ///   SumObserver        Sum(aggregation_temporality=cumulative;is_monotonic=true)
    ///   UpDownSumObserver  Sum(aggregation_temporality=cumulative;is_monotonic=false)
    ///   ValueObserver      Gauge()
    var data: Opentelemetry_Proto_Metrics_V1_Metric.OneOf_Data?

    var intGauge: Opentelemetry_Proto_Metrics_V1_IntGauge {
        get {
            if case .intGauge(let v)? = self.data { return v }
            return Opentelemetry_Proto_Metrics_V1_IntGauge()
        }
        set { self.data = .intGauge(newValue) }
    }

    var doubleGauge: Opentelemetry_Proto_Metrics_V1_DoubleGauge {
        get {
            if case .doubleGauge(let v)? = self.data { return v }
            return Opentelemetry_Proto_Metrics_V1_DoubleGauge()
        }
        set { self.data = .doubleGauge(newValue) }
    }

    var intSum: Opentelemetry_Proto_Metrics_V1_IntSum {
        get {
            if case .intSum(let v)? = self.data { return v }
            return Opentelemetry_Proto_Metrics_V1_IntSum()
        }
        set { self.data = .intSum(newValue) }
    }

    var doubleSum: Opentelemetry_Proto_Metrics_V1_DoubleSum {
        get {
            if case .doubleSum(let v)? = self.data { return v }
            return Opentelemetry_Proto_Metrics_V1_DoubleSum()
        }
        set { self.data = .doubleSum(newValue) }
    }

    var intHistogram: Opentelemetry_Proto_Metrics_V1_IntHistogram {
        get {
            if case .intHistogram(let v)? = self.data { return v }
            return Opentelemetry_Proto_Metrics_V1_IntHistogram()
        }
        set { self.data = .intHistogram(newValue) }
    }

    var doubleHistogram: Opentelemetry_Proto_Metrics_V1_DoubleHistogram {
        get {
            if case .doubleHistogram(let v)? = self.data { return v }
            return Opentelemetry_Proto_Metrics_V1_DoubleHistogram()
        }
        set { self.data = .doubleHistogram(newValue) }
    }

    var doubleSummary: Opentelemetry_Proto_Metrics_V1_DoubleSummary {
        get {
            if case .doubleSummary(let v)? = self.data { return v }
            return Opentelemetry_Proto_Metrics_V1_DoubleSummary()
        }
        set { self.data = .doubleSummary(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Data determines the aggregation type (if any) of the metric, what is the
    /// reported value type for the data points, as well as the relatationship to
    /// the time interval over which they are reported.
    ///
    // TODO: Update table after the decision on:
    /// https://github.com/open-telemetry/opentelemetry-specification/issues/731.
    /// By default, metrics recording using the OpenTelemetry API are exported as
    /// (the table does not include MeasurementValueType to avoid extra rows):
    ///
    ///   Instrument         Type
    ///   ----------------------------------------------
    ///   Counter            Sum(aggregation_temporality=delta;is_monotonic=true)
    ///   UpDownCounter      Sum(aggregation_temporality=delta;is_monotonic=false)
    ///   ValueRecorder      TBD
    ///   SumObserver        Sum(aggregation_temporality=cumulative;is_monotonic=true)
    ///   UpDownSumObserver  Sum(aggregation_temporality=cumulative;is_monotonic=false)
    ///   ValueObserver      Gauge()
    enum OneOf_Data: Equatable {
        case intGauge(Opentelemetry_Proto_Metrics_V1_IntGauge)
        case doubleGauge(Opentelemetry_Proto_Metrics_V1_DoubleGauge)
        case intSum(Opentelemetry_Proto_Metrics_V1_IntSum)
        case doubleSum(Opentelemetry_Proto_Metrics_V1_DoubleSum)
        case intHistogram(Opentelemetry_Proto_Metrics_V1_IntHistogram)
        case doubleHistogram(Opentelemetry_Proto_Metrics_V1_DoubleHistogram)
        case doubleSummary(Opentelemetry_Proto_Metrics_V1_DoubleSummary)

        #if !swift(>=4.1)
        static func == (lhs: Opentelemetry_Proto_Metrics_V1_Metric.OneOf_Data, rhs: Opentelemetry_Proto_Metrics_V1_Metric.OneOf_Data) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.intGauge, .intGauge): return {
                guard case .intGauge(let l) = lhs, case .intGauge(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.doubleGauge, .doubleGauge): return {
                guard case .doubleGauge(let l) = lhs, case .doubleGauge(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.intSum, .intSum): return {
                guard case .intSum(let l) = lhs, case .intSum(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.doubleSum, .doubleSum): return {
                guard case .doubleSum(let l) = lhs, case .doubleSum(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.intHistogram, .intHistogram): return {
                guard case .intHistogram(let l) = lhs, case .intHistogram(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.doubleHistogram, .doubleHistogram): return {
                guard case .doubleHistogram(let l) = lhs, case .doubleHistogram(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.doubleSummary, .doubleSummary): return {
                guard case .doubleSummary(let l) = lhs, case .doubleSummary(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            default: return false
            }
        }
        #endif
    }

    init() {}
}

/// Gauge represents the type of a int scalar metric that always exports the
/// "current value" for every data point. It should be used for an "unknown"
/// aggregation.
///
/// A Gauge does not support different aggregation temporalities. Given the
/// aggregation is unknown, points cannot be combined using the same
/// aggregation, regardless of aggregation temporalities. Therefore,
/// AggregationTemporality is not included. Consequently, this also means
/// "StartTimeUnixNano" is ignored for all data points.
struct Opentelemetry_Proto_Metrics_V1_IntGauge {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dataPoints: [Opentelemetry_Proto_Metrics_V1_IntDataPoint] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Gauge represents the type of a double scalar metric that always exports the
/// "current value" for every data point. It should be used for an "unknown"
/// aggregation.
///
/// A Gauge does not support different aggregation temporalities. Given the
/// aggregation is unknown, points cannot be combined using the same
/// aggregation, regardless of aggregation temporalities. Therefore,
/// AggregationTemporality is not included. Consequently, this also means
/// "StartTimeUnixNano" is ignored for all data points.
struct Opentelemetry_Proto_Metrics_V1_DoubleGauge {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dataPoints: [Opentelemetry_Proto_Metrics_V1_DoubleDataPoint] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Sum represents the type of a numeric int scalar metric that is calculated as
/// a sum of all reported measurements over a time interval.
struct Opentelemetry_Proto_Metrics_V1_IntSum {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dataPoints: [Opentelemetry_Proto_Metrics_V1_IntDataPoint] = []

    /// aggregation_temporality describes if the aggregator reports delta changes
    /// since last report time, or cumulative changes since a fixed start time.
    var aggregationTemporality: Opentelemetry_Proto_Metrics_V1_AggregationTemporality = .unspecified

    /// If "true" means that the sum is monotonic.
    var isMonotonic: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Sum represents the type of a numeric double scalar metric that is calculated
/// as a sum of all reported measurements over a time interval.
struct Opentelemetry_Proto_Metrics_V1_DoubleSum {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dataPoints: [Opentelemetry_Proto_Metrics_V1_DoubleDataPoint] = []

    /// aggregation_temporality describes if the aggregator reports delta changes
    /// since last report time, or cumulative changes since a fixed start time.
    var aggregationTemporality: Opentelemetry_Proto_Metrics_V1_AggregationTemporality = .unspecified

    /// If "true" means that the sum is monotonic.
    var isMonotonic: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Represents the type of a metric that is calculated by aggregating as a
/// Histogram of all reported int measurements over a time interval.
struct Opentelemetry_Proto_Metrics_V1_IntHistogram {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dataPoints: [Opentelemetry_Proto_Metrics_V1_IntHistogramDataPoint] = []

    /// aggregation_temporality describes if the aggregator reports delta changes
    /// since last report time, or cumulative changes since a fixed start time.
    var aggregationTemporality: Opentelemetry_Proto_Metrics_V1_AggregationTemporality = .unspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Represents the type of a metric that is calculated by aggregating as a
/// Histogram of all reported double measurements over a time interval.
struct Opentelemetry_Proto_Metrics_V1_DoubleHistogram {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dataPoints: [Opentelemetry_Proto_Metrics_V1_DoubleHistogramDataPoint] = []

    /// aggregation_temporality describes if the aggregator reports delta changes
    /// since last report time, or cumulative changes since a fixed start time.
    var aggregationTemporality: Opentelemetry_Proto_Metrics_V1_AggregationTemporality = .unspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// DoubleSummary metric data are used to convey quantile summaries,
/// a Prometheus (see: https://prometheus.io/docs/concepts/metric_types/#summary)
/// and OpenMetrics (see: https://github.com/OpenObservability/OpenMetrics/blob/4dbf6075567ab43296eed941037c12951faafb92/protos/prometheus.proto#L45)
/// data type. These data points cannot always be merged in a meaningful way.
/// While they can be useful in some applications, histogram data points are
/// recommended for new applications.
struct Opentelemetry_Proto_Metrics_V1_DoubleSummary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dataPoints: [Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// IntDataPoint is a single data point in a timeseries that describes the
/// time-varying values of a int64 metric.
struct Opentelemetry_Proto_Metrics_V1_IntDataPoint {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The set of labels that uniquely identify this timeseries.
    var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

    /// start_time_unix_nano is the last time when the aggregation value was reset
    /// to "zero". For some metric types this is ignored, see data types for more
    /// details.
    ///
    /// The aggregation value is over the time interval (start_time_unix_nano,
    /// time_unix_nano].
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    ///
    /// Value of 0 indicates that the timestamp is unspecified. In that case the
    /// timestamp may be decided by the backend.
    var startTimeUnixNano: UInt64 = 0

    /// time_unix_nano is the moment when this aggregation value was reported.
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    var timeUnixNano: UInt64 = 0

    /// value itself.
    var value: Int64 = 0

    /// (Optional) List of exemplars collected from
    /// measurements that were used to form the data point
    var exemplars: [Opentelemetry_Proto_Metrics_V1_IntExemplar] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// DoubleDataPoint is a single data point in a timeseries that describes the
/// time-varying value of a double metric.
struct Opentelemetry_Proto_Metrics_V1_DoubleDataPoint {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The set of labels that uniquely identify this timeseries.
    var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

    /// start_time_unix_nano is the last time when the aggregation value was reset
    /// to "zero". For some metric types this is ignored, see data types for more
    /// details.
    ///
    /// The aggregation value is over the time interval (start_time_unix_nano,
    /// time_unix_nano].
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    ///
    /// Value of 0 indicates that the timestamp is unspecified. In that case the
    /// timestamp may be decided by the backend.
    var startTimeUnixNano: UInt64 = 0

    /// time_unix_nano is the moment when this aggregation value was reported.
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    var timeUnixNano: UInt64 = 0

    /// value itself.
    var value: Double = 0

    /// (Optional) List of exemplars collected from
    /// measurements that were used to form the data point
    var exemplars: [Opentelemetry_Proto_Metrics_V1_DoubleExemplar] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// IntHistogramDataPoint is a single data point in a timeseries that describes
/// the time-varying values of a Histogram of int values. A Histogram contains
/// summary statistics for a population of values, it may optionally contain
/// the distribution of those values across a set of buckets.
struct Opentelemetry_Proto_Metrics_V1_IntHistogramDataPoint {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The set of labels that uniquely identify this timeseries.
    var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

    /// start_time_unix_nano is the last time when the aggregation value was reset
    /// to "zero". For some metric types this is ignored, see data types for more
    /// details.
    ///
    /// The aggregation value is over the time interval (start_time_unix_nano,
    /// time_unix_nano].
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    ///
    /// Value of 0 indicates that the timestamp is unspecified. In that case the
    /// timestamp may be decided by the backend.
    var startTimeUnixNano: UInt64 = 0

    /// time_unix_nano is the moment when this aggregation value was reported.
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    var timeUnixNano: UInt64 = 0

    /// count is the number of values in the population. Must be non-negative. This
    /// value must be equal to the sum of the "count" fields in buckets if a
    /// histogram is provided.
    var count: UInt64 = 0

    /// sum of the values in the population. If count is zero then this field
    /// must be zero. This value must be equal to the sum of the "sum" fields in
    /// buckets if a histogram is provided.
    var sum: Int64 = 0

    /// bucket_counts is an optional field contains the count values of histogram
    /// for each bucket.
    ///
    /// The sum of the bucket_counts must equal the value in the count field.
    ///
    /// The number of elements in bucket_counts array must be by one greater than
    /// the number of elements in explicit_bounds array.
    var bucketCounts: [UInt64] = []

    /// explicit_bounds specifies buckets with explicitly defined bounds for values.
    /// The bucket boundaries are described by "bounds" field.
    ///
    /// This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
    /// at index i are:
    ///
    /// (-infinity, bounds[i]) for i == 0
    /// [bounds[i-1], bounds[i]) for 0 < i < N-1
    /// [bounds[i], +infinity) for i == N-1
    /// The values in bounds array must be strictly increasing.
    ///
    /// Note: only [a, b) intervals are currently supported for each bucket except the first one.
    /// If we decide to also support (a, b] intervals we should add support for these by defining
    /// a boolean value which decides what type of intervals to use.
    var explicitBounds: [Double] = []

    /// (Optional) List of exemplars collected from
    /// measurements that were used to form the data point
    var exemplars: [Opentelemetry_Proto_Metrics_V1_IntExemplar] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// HistogramDataPoint is a single data point in a timeseries that describes the
/// time-varying values of a Histogram of double values. A Histogram contains
/// summary statistics for a population of values, it may optionally contain the
/// distribution of those values across a set of buckets.
struct Opentelemetry_Proto_Metrics_V1_DoubleHistogramDataPoint {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The set of labels that uniquely identify this timeseries.
    var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

    /// start_time_unix_nano is the last time when the aggregation value was reset
    /// to "zero". For some metric types this is ignored, see data types for more
    /// details.
    ///
    /// The aggregation value is over the time interval (start_time_unix_nano,
    /// time_unix_nano].
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    ///
    /// Value of 0 indicates that the timestamp is unspecified. In that case the
    /// timestamp may be decided by the backend.
    var startTimeUnixNano: UInt64 = 0

    /// time_unix_nano is the moment when this aggregation value was reported.
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    var timeUnixNano: UInt64 = 0

    /// count is the number of values in the population. Must be non-negative. This
    /// value must be equal to the sum of the "count" fields in buckets if a
    /// histogram is provided.
    var count: UInt64 = 0

    /// sum of the values in the population. If count is zero then this field
    /// must be zero. This value must be equal to the sum of the "sum" fields in
    /// buckets if a histogram is provided.
    var sum: Double = 0

    /// bucket_counts is an optional field contains the count values of histogram
    /// for each bucket.
    ///
    /// The sum of the bucket_counts must equal the value in the count field.
    ///
    /// The number of elements in bucket_counts array must be by one greater than
    /// the number of elements in explicit_bounds array.
    var bucketCounts: [UInt64] = []

    /// explicit_bounds specifies buckets with explicitly defined bounds for values.
    /// The bucket boundaries are described by "bounds" field.
    ///
    /// This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
    /// at index i are:
    ///
    /// (-infinity, bounds[i]) for i == 0
    /// [bounds[i-1], bounds[i]) for 0 < i < N-1
    /// [bounds[i], +infinity) for i == N-1
    /// The values in bounds array must be strictly increasing.
    ///
    /// Note: only [a, b) intervals are currently supported for each bucket except the first one.
    /// If we decide to also support (a, b] intervals we should add support for these by defining
    /// a boolean value which decides what type of intervals to use.
    var explicitBounds: [Double] = []

    /// (Optional) List of exemplars collected from
    /// measurements that were used to form the data point
    var exemplars: [Opentelemetry_Proto_Metrics_V1_DoubleExemplar] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// DoubleSummaryDataPoint is a single data point in a timeseries that describes the
/// time-varying values of a Summary metric.
struct Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The set of labels that uniquely identify this timeseries.
    var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

    /// start_time_unix_nano is the last time when the aggregation value was reset
    /// to "zero". For some metric types this is ignored, see data types for more
    /// details.
    ///
    /// The aggregation value is over the time interval (start_time_unix_nano,
    /// time_unix_nano].
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    ///
    /// Value of 0 indicates that the timestamp is unspecified. In that case the
    /// timestamp may be decided by the backend.
    var startTimeUnixNano: UInt64 = 0

    /// time_unix_nano is the moment when this aggregation value was reported.
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    var timeUnixNano: UInt64 = 0

    /// count is the number of values in the population. Must be non-negative.
    var count: UInt64 = 0

    /// sum of the values in the population. If count is zero then this field
    /// must be zero.
    var sum: Double = 0

    /// (Optional) list of values at different quantiles of the distribution calculated
    /// from the current snapshot. The quantiles must be strictly increasing.
    var quantileValues: [Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint.ValueAtQuantile] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Represents the value at a given quantile of a distribution.
    ///
    /// To record Min and Max values following conventions are used:
    /// - The 1.0 quantile is equivalent to the maximum value observed.
    /// - The 0.0 quantile is equivalent to the minimum value observed.
    ///
    /// See the following issue for more context:
    /// https://github.com/open-telemetry/opentelemetry-proto/issues/125
    struct ValueAtQuantile {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// The quantile of a distribution. Must be in the interval
        /// [0.0, 1.0].
        var quantile: Double = 0

        /// The value at the given quantile of a distribution.
        var value: Double = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
    }

    init() {}
}

/// A representation of an exemplar, which is a sample input int measurement.
/// Exemplars also hold information about the environment when the measurement
/// was recorded, for example the span and trace ID of the active span when the
/// exemplar was recorded.
struct Opentelemetry_Proto_Metrics_V1_IntExemplar {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The set of labels that were filtered out by the aggregator, but recorded
    /// alongside the original measurement. Only labels that were filtered out
    /// by the aggregator should be included
    var filteredLabels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

    /// time_unix_nano is the exact time when this exemplar was recorded
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    var timeUnixNano: UInt64 = 0

    /// Numerical int value of the measurement that was recorded.
    var value: Int64 = 0

    /// (Optional) Span ID of the exemplar trace.
    /// span_id may be missing if the measurement is not recorded inside a trace
    /// or if the trace is not sampled.
    var spanID: Data = Data()

    /// (Optional) Trace ID of the exemplar trace.
    /// trace_id may be missing if the measurement is not recorded inside a trace
    /// or if the trace is not sampled.
    var traceID: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// A representation of an exemplar, which is a sample input double measurement.
/// Exemplars also hold information about the environment when the measurement
/// was recorded, for example the span and trace ID of the active span when the
/// exemplar was recorded.
struct Opentelemetry_Proto_Metrics_V1_DoubleExemplar {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The set of labels that were filtered out by the aggregator, but recorded
    /// alongside the original measurement. Only labels that were filtered out
    /// by the aggregator should be included
    var filteredLabels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

    /// time_unix_nano is the exact time when this exemplar was recorded
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    var timeUnixNano: UInt64 = 0

    /// Numerical double value of the measurement that was recorded.
    var value: Double = 0

    /// (Optional) Span ID of the exemplar trace.
    /// span_id may be missing if the measurement is not recorded inside a trace
    /// or if the trace is not sampled.
    var spanID: Data = Data()

    /// (Optional) Trace ID of the exemplar trace.
    /// trace_id may be missing if the measurement is not recorded inside a trace
    /// or if the trace is not sampled.
    var traceID: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "opentelemetry.proto.metrics.v1"

extension Opentelemetry_Proto_Metrics_V1_AggregationTemporality: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "AGGREGATION_TEMPORALITY_UNSPECIFIED"),
        1: .same(proto: "AGGREGATION_TEMPORALITY_DELTA"),
        2: .same(proto: "AGGREGATION_TEMPORALITY_CUMULATIVE"),
    ]
}

extension Opentelemetry_Proto_Metrics_V1_ResourceMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ResourceMetrics"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "resource"),
        2: .standard(proto: "instrumentation_library_metrics"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instrumentationLibraryMetrics) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if let v = self._resource {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !self.instrumentationLibraryMetrics.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.instrumentationLibraryMetrics, fieldNumber: 2)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_ResourceMetrics, rhs: Opentelemetry_Proto_Metrics_V1_ResourceMetrics) -> Bool {
        if lhs._resource != rhs._resource { return false }
        if lhs.instrumentationLibraryMetrics != rhs.instrumentationLibraryMetrics { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".InstrumentationLibraryMetrics"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "instrumentation_library"),
        2: .same(proto: "metrics"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._instrumentationLibrary) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.metrics) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if let v = self._instrumentationLibrary {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !self.metrics.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.metrics, fieldNumber: 2)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics, rhs: Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics) -> Bool {
        if lhs._instrumentationLibrary != rhs._instrumentationLibrary { return false }
        if lhs.metrics != rhs.metrics { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_Metric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Metric"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "description"),
        3: .same(proto: "unit"),
        4: .standard(proto: "int_gauge"),
        5: .standard(proto: "double_gauge"),
        6: .standard(proto: "int_sum"),
        7: .standard(proto: "double_sum"),
        8: .standard(proto: "int_histogram"),
        9: .standard(proto: "double_histogram"),
        11: .standard(proto: "double_summary"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.unit) }()
            case 4: try {
                var v: Opentelemetry_Proto_Metrics_V1_IntGauge?
                if let current = self.data {
                    try decoder.handleConflictingOneOf()
                    if case .intGauge(let m) = current { v = m }
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v { self.data = .intGauge(v) }
            }()
            case 5: try {
                var v: Opentelemetry_Proto_Metrics_V1_DoubleGauge?
                if let current = self.data {
                    try decoder.handleConflictingOneOf()
                    if case .doubleGauge(let m) = current { v = m }
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v { self.data = .doubleGauge(v) }
            }()
            case 6: try {
                var v: Opentelemetry_Proto_Metrics_V1_IntSum?
                if let current = self.data {
                    try decoder.handleConflictingOneOf()
                    if case .intSum(let m) = current { v = m }
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v { self.data = .intSum(v) }
            }()
            case 7: try {
                var v: Opentelemetry_Proto_Metrics_V1_DoubleSum?
                if let current = self.data {
                    try decoder.handleConflictingOneOf()
                    if case .doubleSum(let m) = current { v = m }
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v { self.data = .doubleSum(v) }
            }()
            case 8: try {
                var v: Opentelemetry_Proto_Metrics_V1_IntHistogram?
                if let current = self.data {
                    try decoder.handleConflictingOneOf()
                    if case .intHistogram(let m) = current { v = m }
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v { self.data = .intHistogram(v) }
            }()
            case 9: try {
                var v: Opentelemetry_Proto_Metrics_V1_DoubleHistogram?
                if let current = self.data {
                    try decoder.handleConflictingOneOf()
                    if case .doubleHistogram(let m) = current { v = m }
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v { self.data = .doubleHistogram(v) }
            }()
            case 11: try {
                var v: Opentelemetry_Proto_Metrics_V1_DoubleSummary?
                if let current = self.data {
                    try decoder.handleConflictingOneOf()
                    if case .doubleSummary(let m) = current { v = m }
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v { self.data = .doubleSummary(v) }
            }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.name.isEmpty {
            try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
        }
        if !self.description_p.isEmpty {
            try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
        }
        if !self.unit.isEmpty {
            try visitor.visitSingularStringField(value: self.unit, fieldNumber: 3)
        }
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch self.data {
        case .intGauge?: try {
            guard case .intGauge(let v)? = self.data else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        }()
        case .doubleGauge?: try {
            guard case .doubleGauge(let v)? = self.data else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        }()
        case .intSum?: try {
            guard case .intSum(let v)? = self.data else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
        }()
        case .doubleSum?: try {
            guard case .doubleSum(let v)? = self.data else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
        }()
        case .intHistogram?: try {
            guard case .intHistogram(let v)? = self.data else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
        }()
        case .doubleHistogram?: try {
            guard case .doubleHistogram(let v)? = self.data else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
        }()
        case .doubleSummary?: try {
            guard case .doubleSummary(let v)? = self.data else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
        }()
        case nil: break
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_Metric, rhs: Opentelemetry_Proto_Metrics_V1_Metric) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.unit != rhs.unit { return false }
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_IntGauge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".IntGauge"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "data_points"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.dataPoints.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_IntGauge, rhs: Opentelemetry_Proto_Metrics_V1_IntGauge) -> Bool {
        if lhs.dataPoints != rhs.dataPoints { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleGauge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DoubleGauge"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "data_points"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.dataPoints.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_DoubleGauge, rhs: Opentelemetry_Proto_Metrics_V1_DoubleGauge) -> Bool {
        if lhs.dataPoints != rhs.dataPoints { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_IntSum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".IntSum"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "data_points"),
        2: .standard(proto: "aggregation_temporality"),
        3: .standard(proto: "is_monotonic"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
            case 2: try { try decoder.decodeSingularEnumField(value: &self.aggregationTemporality) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.isMonotonic) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.dataPoints.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
        }
        if self.aggregationTemporality != .unspecified {
            try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 2)
        }
        if self.isMonotonic != false {
            try visitor.visitSingularBoolField(value: self.isMonotonic, fieldNumber: 3)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_IntSum, rhs: Opentelemetry_Proto_Metrics_V1_IntSum) -> Bool {
        if lhs.dataPoints != rhs.dataPoints { return false }
        if lhs.aggregationTemporality != rhs.aggregationTemporality { return false }
        if lhs.isMonotonic != rhs.isMonotonic { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleSum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DoubleSum"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "data_points"),
        2: .standard(proto: "aggregation_temporality"),
        3: .standard(proto: "is_monotonic"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
            case 2: try { try decoder.decodeSingularEnumField(value: &self.aggregationTemporality) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.isMonotonic) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.dataPoints.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
        }
        if self.aggregationTemporality != .unspecified {
            try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 2)
        }
        if self.isMonotonic != false {
            try visitor.visitSingularBoolField(value: self.isMonotonic, fieldNumber: 3)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_DoubleSum, rhs: Opentelemetry_Proto_Metrics_V1_DoubleSum) -> Bool {
        if lhs.dataPoints != rhs.dataPoints { return false }
        if lhs.aggregationTemporality != rhs.aggregationTemporality { return false }
        if lhs.isMonotonic != rhs.isMonotonic { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_IntHistogram: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".IntHistogram"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "data_points"),
        2: .standard(proto: "aggregation_temporality"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
            case 2: try { try decoder.decodeSingularEnumField(value: &self.aggregationTemporality) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.dataPoints.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
        }
        if self.aggregationTemporality != .unspecified {
            try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 2)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_IntHistogram, rhs: Opentelemetry_Proto_Metrics_V1_IntHistogram) -> Bool {
        if lhs.dataPoints != rhs.dataPoints { return false }
        if lhs.aggregationTemporality != rhs.aggregationTemporality { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleHistogram: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DoubleHistogram"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "data_points"),
        2: .standard(proto: "aggregation_temporality"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
            case 2: try { try decoder.decodeSingularEnumField(value: &self.aggregationTemporality) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.dataPoints.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
        }
        if self.aggregationTemporality != .unspecified {
            try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 2)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_DoubleHistogram, rhs: Opentelemetry_Proto_Metrics_V1_DoubleHistogram) -> Bool {
        if lhs.dataPoints != rhs.dataPoints { return false }
        if lhs.aggregationTemporality != rhs.aggregationTemporality { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DoubleSummary"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "data_points"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.dataPoints.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_DoubleSummary, rhs: Opentelemetry_Proto_Metrics_V1_DoubleSummary) -> Bool {
        if lhs.dataPoints != rhs.dataPoints { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_IntDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".IntDataPoint"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "labels"),
        2: .standard(proto: "start_time_unix_nano"),
        3: .standard(proto: "time_unix_nano"),
        4: .same(proto: "value"),
        5: .same(proto: "exemplars"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.labels) }()
            case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano) }()
            case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
            case 4: try { try decoder.decodeSingularSFixed64Field(value: &self.value) }()
            case 5: try { try decoder.decodeRepeatedMessageField(value: &self.exemplars) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.labels.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
        }
        if self.startTimeUnixNano != 0 {
            try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
        }
        if self.timeUnixNano != 0 {
            try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
        }
        if self.value != 0 {
            try visitor.visitSingularSFixed64Field(value: self.value, fieldNumber: 4)
        }
        if !self.exemplars.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.exemplars, fieldNumber: 5)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_IntDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_IntDataPoint) -> Bool {
        if lhs.labels != rhs.labels { return false }
        if lhs.startTimeUnixNano != rhs.startTimeUnixNano { return false }
        if lhs.timeUnixNano != rhs.timeUnixNano { return false }
        if lhs.value != rhs.value { return false }
        if lhs.exemplars != rhs.exemplars { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DoubleDataPoint"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "labels"),
        2: .standard(proto: "start_time_unix_nano"),
        3: .standard(proto: "time_unix_nano"),
        4: .same(proto: "value"),
        5: .same(proto: "exemplars"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.labels) }()
            case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano) }()
            case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
            case 4: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
            case 5: try { try decoder.decodeRepeatedMessageField(value: &self.exemplars) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.labels.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
        }
        if self.startTimeUnixNano != 0 {
            try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
        }
        if self.timeUnixNano != 0 {
            try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
        }
        if self.value != 0 {
            try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 4)
        }
        if !self.exemplars.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.exemplars, fieldNumber: 5)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_DoubleDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_DoubleDataPoint) -> Bool {
        if lhs.labels != rhs.labels { return false }
        if lhs.startTimeUnixNano != rhs.startTimeUnixNano { return false }
        if lhs.timeUnixNano != rhs.timeUnixNano { return false }
        if lhs.value != rhs.value { return false }
        if lhs.exemplars != rhs.exemplars { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_IntHistogramDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".IntHistogramDataPoint"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "labels"),
        2: .standard(proto: "start_time_unix_nano"),
        3: .standard(proto: "time_unix_nano"),
        4: .same(proto: "count"),
        5: .same(proto: "sum"),
        6: .standard(proto: "bucket_counts"),
        7: .standard(proto: "explicit_bounds"),
        8: .same(proto: "exemplars"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.labels) }()
            case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano) }()
            case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
            case 4: try { try decoder.decodeSingularFixed64Field(value: &self.count) }()
            case 5: try { try decoder.decodeSingularSFixed64Field(value: &self.sum) }()
            case 6: try { try decoder.decodeRepeatedFixed64Field(value: &self.bucketCounts) }()
            case 7: try { try decoder.decodeRepeatedDoubleField(value: &self.explicitBounds) }()
            case 8: try { try decoder.decodeRepeatedMessageField(value: &self.exemplars) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.labels.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
        }
        if self.startTimeUnixNano != 0 {
            try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
        }
        if self.timeUnixNano != 0 {
            try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
        }
        if self.count != 0 {
            try visitor.visitSingularFixed64Field(value: self.count, fieldNumber: 4)
        }
        if self.sum != 0 {
            try visitor.visitSingularSFixed64Field(value: self.sum, fieldNumber: 5)
        }
        if !self.bucketCounts.isEmpty {
            try visitor.visitPackedFixed64Field(value: self.bucketCounts, fieldNumber: 6)
        }
        if !self.explicitBounds.isEmpty {
            try visitor.visitPackedDoubleField(value: self.explicitBounds, fieldNumber: 7)
        }
        if !self.exemplars.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.exemplars, fieldNumber: 8)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_IntHistogramDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_IntHistogramDataPoint) -> Bool {
        if lhs.labels != rhs.labels { return false }
        if lhs.startTimeUnixNano != rhs.startTimeUnixNano { return false }
        if lhs.timeUnixNano != rhs.timeUnixNano { return false }
        if lhs.count != rhs.count { return false }
        if lhs.sum != rhs.sum { return false }
        if lhs.bucketCounts != rhs.bucketCounts { return false }
        if lhs.explicitBounds != rhs.explicitBounds { return false }
        if lhs.exemplars != rhs.exemplars { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleHistogramDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DoubleHistogramDataPoint"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "labels"),
        2: .standard(proto: "start_time_unix_nano"),
        3: .standard(proto: "time_unix_nano"),
        4: .same(proto: "count"),
        5: .same(proto: "sum"),
        6: .standard(proto: "bucket_counts"),
        7: .standard(proto: "explicit_bounds"),
        8: .same(proto: "exemplars"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.labels) }()
            case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano) }()
            case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
            case 4: try { try decoder.decodeSingularFixed64Field(value: &self.count) }()
            case 5: try { try decoder.decodeSingularDoubleField(value: &self.sum) }()
            case 6: try { try decoder.decodeRepeatedFixed64Field(value: &self.bucketCounts) }()
            case 7: try { try decoder.decodeRepeatedDoubleField(value: &self.explicitBounds) }()
            case 8: try { try decoder.decodeRepeatedMessageField(value: &self.exemplars) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.labels.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
        }
        if self.startTimeUnixNano != 0 {
            try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
        }
        if self.timeUnixNano != 0 {
            try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
        }
        if self.count != 0 {
            try visitor.visitSingularFixed64Field(value: self.count, fieldNumber: 4)
        }
        if self.sum != 0 {
            try visitor.visitSingularDoubleField(value: self.sum, fieldNumber: 5)
        }
        if !self.bucketCounts.isEmpty {
            try visitor.visitPackedFixed64Field(value: self.bucketCounts, fieldNumber: 6)
        }
        if !self.explicitBounds.isEmpty {
            try visitor.visitPackedDoubleField(value: self.explicitBounds, fieldNumber: 7)
        }
        if !self.exemplars.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.exemplars, fieldNumber: 8)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_DoubleHistogramDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_DoubleHistogramDataPoint) -> Bool {
        if lhs.labels != rhs.labels { return false }
        if lhs.startTimeUnixNano != rhs.startTimeUnixNano { return false }
        if lhs.timeUnixNano != rhs.timeUnixNano { return false }
        if lhs.count != rhs.count { return false }
        if lhs.sum != rhs.sum { return false }
        if lhs.bucketCounts != rhs.bucketCounts { return false }
        if lhs.explicitBounds != rhs.explicitBounds { return false }
        if lhs.exemplars != rhs.exemplars { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DoubleSummaryDataPoint"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "labels"),
        2: .standard(proto: "start_time_unix_nano"),
        3: .standard(proto: "time_unix_nano"),
        4: .same(proto: "count"),
        5: .same(proto: "sum"),
        6: .standard(proto: "quantile_values"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.labels) }()
            case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano) }()
            case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
            case 4: try { try decoder.decodeSingularFixed64Field(value: &self.count) }()
            case 5: try { try decoder.decodeSingularDoubleField(value: &self.sum) }()
            case 6: try { try decoder.decodeRepeatedMessageField(value: &self.quantileValues) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.labels.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
        }
        if self.startTimeUnixNano != 0 {
            try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
        }
        if self.timeUnixNano != 0 {
            try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
        }
        if self.count != 0 {
            try visitor.visitSingularFixed64Field(value: self.count, fieldNumber: 4)
        }
        if self.sum != 0 {
            try visitor.visitSingularDoubleField(value: self.sum, fieldNumber: 5)
        }
        if !self.quantileValues.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.quantileValues, fieldNumber: 6)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint) -> Bool {
        if lhs.labels != rhs.labels { return false }
        if lhs.startTimeUnixNano != rhs.startTimeUnixNano { return false }
        if lhs.timeUnixNano != rhs.timeUnixNano { return false }
        if lhs.count != rhs.count { return false }
        if lhs.sum != rhs.sum { return false }
        if lhs.quantileValues != rhs.quantileValues { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint.ValueAtQuantile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint.protoMessageName + ".ValueAtQuantile"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "quantile"),
        2: .same(proto: "value"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularDoubleField(value: &self.quantile) }()
            case 2: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.quantile != 0 {
            try visitor.visitSingularDoubleField(value: self.quantile, fieldNumber: 1)
        }
        if self.value != 0 {
            try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 2)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint.ValueAtQuantile, rhs: Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint.ValueAtQuantile) -> Bool {
        if lhs.quantile != rhs.quantile { return false }
        if lhs.value != rhs.value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_IntExemplar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".IntExemplar"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "filtered_labels"),
        2: .standard(proto: "time_unix_nano"),
        3: .same(proto: "value"),
        4: .standard(proto: "span_id"),
        5: .standard(proto: "trace_id"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.filteredLabels) }()
            case 2: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
            case 3: try { try decoder.decodeSingularSFixed64Field(value: &self.value) }()
            case 4: try { try decoder.decodeSingularBytesField(value: &self.spanID) }()
            case 5: try { try decoder.decodeSingularBytesField(value: &self.traceID) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.filteredLabels.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.filteredLabels, fieldNumber: 1)
        }
        if self.timeUnixNano != 0 {
            try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 2)
        }
        if self.value != 0 {
            try visitor.visitSingularSFixed64Field(value: self.value, fieldNumber: 3)
        }
        if !self.spanID.isEmpty {
            try visitor.visitSingularBytesField(value: self.spanID, fieldNumber: 4)
        }
        if !self.traceID.isEmpty {
            try visitor.visitSingularBytesField(value: self.traceID, fieldNumber: 5)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_IntExemplar, rhs: Opentelemetry_Proto_Metrics_V1_IntExemplar) -> Bool {
        if lhs.filteredLabels != rhs.filteredLabels { return false }
        if lhs.timeUnixNano != rhs.timeUnixNano { return false }
        if lhs.value != rhs.value { return false }
        if lhs.spanID != rhs.spanID { return false }
        if lhs.traceID != rhs.traceID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleExemplar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DoubleExemplar"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "filtered_labels"),
        2: .standard(proto: "time_unix_nano"),
        3: .same(proto: "value"),
        4: .standard(proto: "span_id"),
        5: .standard(proto: "trace_id"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.filteredLabels) }()
            case 2: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
            case 3: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
            case 4: try { try decoder.decodeSingularBytesField(value: &self.spanID) }()
            case 5: try { try decoder.decodeSingularBytesField(value: &self.traceID) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.filteredLabels.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.filteredLabels, fieldNumber: 1)
        }
        if self.timeUnixNano != 0 {
            try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 2)
        }
        if self.value != 0 {
            try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 3)
        }
        if !self.spanID.isEmpty {
            try visitor.visitSingularBytesField(value: self.spanID, fieldNumber: 4)
        }
        if !self.traceID.isEmpty {
            try visitor.visitSingularBytesField(value: self.traceID, fieldNumber: 5)
        }
        try self.unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Metrics_V1_DoubleExemplar, rhs: Opentelemetry_Proto_Metrics_V1_DoubleExemplar) -> Bool {
        if lhs.filteredLabels != rhs.filteredLabels { return false }
        if lhs.timeUnixNano != rhs.timeUnixNano { return false }
        if lhs.value != rhs.value { return false }
        if lhs.spanID != rhs.spanID { return false }
        if lhs.traceID != rhs.traceID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
